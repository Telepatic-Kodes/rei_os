---
phase: 05-data-infrastructure
plan: 02
type: execute
wave: 2
depends_on: ["05-01"]
files_modified:
  - app/src/lib/data.ts
  - scripts/sync-tokens.ts
  - scripts/sync-quality.ts
  - scripts/sync-projects.ts
  - .gitignore
autonomous: true

must_haves:
  truths:
    - "Running any sync script twice produces identical data files (idempotent)"
    - "Auto-generated data files are gitignored while seed/config data is tracked"
    - "data.ts uses Zod validation instead of unsafe 'as T' casts"
    - "Sync scripts use atomic writes instead of direct writeFileSync"
  artifacts:
    - path: "app/src/lib/data.ts"
      provides: "Refactored data layer using Zod schemas and atomic writes"
      exports: ["getProjects", "writeProjects", "getTokenData", "writeTokenData", "getQuality", "getBudgetConfig"]
    - path: "scripts/sync-tokens.ts"
      provides: "Token sync using atomic writes and JSONL history append"
      contains: "atomicWriteJson"
    - path: ".gitignore"
      provides: "Gitignore rules for auto-generated data"
      contains: "data/history/"
  key_links:
    - from: "app/src/lib/data.ts"
      to: "app/src/lib/schemas.ts"
      via: "imports Zod schemas for validation"
      pattern: "import.*schemas"
    - from: "scripts/sync-tokens.ts"
      to: "app/src/lib/atomic-write.ts"
      via: "uses atomicWriteJson for safe file writes"
      pattern: "atomicWriteJson"
    - from: "scripts/sync-tokens.ts"
      to: "app/src/lib/jsonl.ts"
      via: "appends to JSONL history after sync"
      pattern: "appendJsonl"
---

<objective>
Refactor data.ts to use Zod validation and atomic writes, update all sync scripts to use the new utilities, and configure gitignore for auto-generated vs tracked data.

Purpose: Complete the safety layer so no sync operation can corrupt data or produce unvalidated output. This makes Phase 6 (automated sync) safe to run unattended.
Output: Refactored data.ts, updated sync scripts, proper .gitignore rules.
</objective>

<execution_context>
@/home/tomas/.claude/get-shit-done/workflows/execute-plan.md
@/home/tomas/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-data-infrastructure/05-01-SUMMARY.md
@app/src/lib/data.ts
@app/src/lib/schemas.ts
@app/src/lib/atomic-write.ts
@app/src/lib/jsonl.ts
@scripts/sync-tokens.ts
@scripts/sync-quality.ts
@scripts/sync-projects.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Refactor data.ts to use Zod schemas and atomic writes</name>
  <files>app/src/lib/data.ts</files>
  <action>
Refactor `app/src/lib/data.ts`:

1. Replace interface definitions with imports from schemas.ts:
   ```typescript
   import { ProjectSchema, TokenDataSchema, QualityEntrySchema, BudgetConfigSchema } from "./schemas";
   import type { Project, TokenData, QualityEntry, BudgetConfig } from "./schemas";
   import { atomicWriteJson } from "./atomic-write";
   ```

2. Replace the generic `readJson<T>` function with a validated version:
   ```typescript
   import { z } from "zod";

   function readValidatedJson<T>(filename: string, schema: z.ZodType<T>): T {
     const filePath = path.join(dataDir, filename);
     const raw = fs.readFileSync(filePath, "utf-8");
     return schema.parse(JSON.parse(raw));
   }
   ```

3. Update all read functions to use schema validation:
   - `getProjects()` -> `readValidatedJson("projects.json", z.array(ProjectSchema))`
   - `getTokenData()` -> `readValidatedJson("tokens.json", TokenDataSchema)`
   - `getQuality()` -> `readValidatedJson("quality.json", z.array(QualityEntrySchema))`

4. Add `getBudgetConfig()`:
   ```typescript
   export function getBudgetConfig(): BudgetConfig {
     return readValidatedJson("config/budget.json", BudgetConfigSchema);
   }
   ```

5. Update write functions to use atomicWriteJson:
   - `writeProjects(projects)` -> validate with `z.array(ProjectSchema).parse(projects)` then `atomicWriteJson(filePath, projects)`
   - `writeTokenData(data)` -> validate with `TokenDataSchema.parse(data)` then `atomicWriteJson(filePath, data)`

6. Keep all existing function signatures and exports intact. Add new exports only (getBudgetConfig). Do NOT remove or rename anything — the dashboard depends on these exact exports.
  </action>
  <verify>
Run: `cd /home/tomas/Escritorio/AIAIAI_Consulting/app && npx tsc --noEmit`
Run: `cd /home/tomas/Escritorio/AIAIAI_Consulting/app && npm run build` to confirm Next.js pages still work with refactored data.ts
  </verify>
  <done>data.ts uses Zod validation on every read and atomic writes on every write. No `as T` casts remain. Dashboard still builds successfully.</done>
</task>

<task type="auto">
  <name>Task 2: Update sync scripts and configure gitignore</name>
  <files>scripts/sync-tokens.ts, scripts/sync-quality.ts, scripts/sync-projects.ts, .gitignore</files>
  <action>
1. Update each sync script to use shared utilities. For each script:
   - Remove duplicated interface definitions (use imports from schemas.ts instead)
   - Replace `writeFileSync` with `atomicWriteJson` from atomic-write.ts
   - After writing the main data file, also append a snapshot to JSONL history using `appendJsonl` from jsonl.ts
   - Ensure idempotency: the dedup logic already exists (session-based for tokens, date+project for quality). Verify it works by checking that running twice produces same output.

   For `scripts/sync-tokens.ts` specifically:
   - Import: `import { atomicWriteJson } from "../app/src/lib/atomic-write";`
   - Import: `import { appendJsonl } from "../app/src/lib/jsonl";`
   - Import: `import { TokenDataSchema, TokenEntrySchema } from "../app/src/lib/schemas";`
   - Replace `writeFileSync(DATA_FILE, ...)` with `atomicWriteJson(DATA_FILE, existing)`
   - After writing, append each new entry to history: `fetched.forEach(entry => appendJsonl(HISTORY_DIR, "tokens", entry))`
   - Where `HISTORY_DIR = join(ROOT, "data", "history")`
   - Remove the local `TokenEntry` and `TokenData` interfaces

   Apply same pattern to sync-quality.ts and sync-projects.ts (import shared schemas, use atomicWriteJson, append to history).

2. Update `.gitignore` (create at repo root if not exists):
   ```
   # Auto-generated data (recreated by sync scripts)
   data/history/

   # Keep tracked
   !data/config/
   !data/*.json
   ```

   This gitignores JSONL history files (which grow over time and are auto-generated) while keeping the main JSON data files and config tracked.

3. Verify idempotency: The existing dedup logic in sync-tokens.ts (filter by session !== "auto-sync", then re-add fetched) already ensures idempotency. Confirm sync-quality.ts and sync-projects.ts have similar dedup. If not, add date+project dedup before writing.
  </action>
  <verify>
Run: `cd /home/tomas/Escritorio/AIAIAI_Consulting/app && npx tsc --noEmit`
Run: `grep -r "writeFileSync" scripts/` — should return NO results (all replaced with atomicWriteJson)
Run: `grep -r "as T\|as TokenData\|as Project" app/src/lib/data.ts` — should return NO results
Run: `cat .gitignore` — confirms data/history/ is ignored
  </verify>
  <done>All sync scripts use atomic writes and append to JSONL history. No duplicated interfaces remain in scripts. Gitignore properly separates auto-generated from tracked data. Running any sync script twice produces identical files.</done>
</task>

</tasks>

<verification>
1. `cd app && npm run build` — Next.js builds without errors (dashboard not broken)
2. `grep -r "writeFileSync" scripts/` — zero matches
3. `grep "as T" app/src/lib/data.ts` — zero matches
4. `grep "renameSync" app/src/lib/atomic-write.ts` — confirms atomic pattern
5. `cat .gitignore | grep "data/history"` — confirms history is gitignored
6. `cat data/config/budget.json` — budget config exists and is valid JSON
</verification>

<success_criteria>
- data.ts validates all reads with Zod, writes with atomicWriteJson
- Zero `as T` casts in data.ts, zero `writeFileSync` in scripts/
- All sync scripts append to JSONL history after writing main data
- .gitignore ignores data/history/ but tracks data/*.json and data/config/
- `npm run build` succeeds (dashboard works)
- Sync scripts are idempotent (dedup logic confirmed)
</success_criteria>

<output>
After completion, create `.planning/phases/05-data-infrastructure/05-02-SUMMARY.md`
</output>
