---
phase: 05-data-infrastructure
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - app/src/lib/schemas.ts
  - app/src/lib/atomic-write.ts
  - app/src/lib/jsonl.ts
  - data/history/.gitkeep
  - data/config/budget.json
autonomous: true

must_haves:
  truths:
    - "Writing a JSON file via atomicWrite never leaves a corrupt file even on simulated crash"
    - "JSONL append creates monthly-rotated files like tokens-2026-01.jsonl"
    - "Zod schemas validate all data shapes and reject malformed data at load time"
    - "Budget config is extracted from tokens.json into data/config/budget.json"
  artifacts:
    - path: "app/src/lib/schemas.ts"
      provides: "Zod schemas for Project, TokenEntry, TokenData, QualityEntry, BudgetConfig, and JSONL history entry"
      exports: ["ProjectSchema", "TokenEntrySchema", "TokenDataSchema", "QualityEntrySchema", "BudgetConfigSchema", "HistoryEntrySchema"]
    - path: "app/src/lib/atomic-write.ts"
      provides: "atomicWriteJson and atomicWriteJsonl functions using tmp+rename pattern"
      exports: ["atomicWriteJson", "atomicWriteJsonl"]
    - path: "app/src/lib/jsonl.ts"
      provides: "JSONL read/append/rotate utilities with monthly file naming"
      exports: ["appendJsonl", "readJsonl", "getMonthlyPath"]
    - path: "data/config/budget.json"
      provides: "Extracted budget configuration"
      contains: "monthly"
  key_links:
    - from: "app/src/lib/atomic-write.ts"
      to: "node:fs"
      via: "writeFileSync to tmp path then renameSync"
      pattern: "renameSync"
    - from: "app/src/lib/jsonl.ts"
      to: "app/src/lib/atomic-write.ts"
      via: "uses atomicWriteJsonl for safe appends"
      pattern: "import.*atomic"
---

<objective>
Create the foundational data utilities: Zod schemas for all data shapes, atomic write functions (temp file + rename), and JSONL history infrastructure with monthly rotation.

Purpose: Every subsequent phase (sync, analytics, alerts) depends on safe writes and typed data. This plan eliminates the unsafe writeFileSync calls and untyped `as T` casts.
Output: Three utility modules (schemas, atomic-write, jsonl) plus extracted budget config file.
</objective>

<execution_context>
@/home/tomas/.claude/get-shit-done/workflows/execute-plan.md
@/home/tomas/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@app/src/lib/data.ts
@data/tokens.json
@scripts/sync-tokens.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Zod schemas and atomic write utilities</name>
  <files>app/src/lib/schemas.ts, app/src/lib/atomic-write.ts</files>
  <action>
1. Install zod: `cd app && npm install zod`

2. Create `app/src/lib/schemas.ts` with Zod schemas matching existing TypeScript interfaces in data.ts:
   - `ProjectSchema` — z.object matching Project interface. status: z.enum(["active", "paused", "completed"]), stack: z.array(z.string()), etc.
   - `TokenEntrySchema` — z.object matching TokenEntry
   - `QualityEntrySchema` — z.object matching QualityEntry, techDebt: z.enum(["none", "low", "medium", "high"])
   - `BudgetConfigSchema` — z.object({ monthly: z.number(), currency: z.string() })
   - `TokenDataSchema` — z.object({ budget: BudgetConfigSchema, entries: z.array(TokenEntrySchema) })
   - `HistoryEntrySchema` — z.object({ timestamp: z.string(), type: z.enum(["tokens", "quality", "projects"]), data: z.unknown() }) for JSONL lines
   - Export inferred types: `export type Project = z.infer<typeof ProjectSchema>` etc.
   - Export a `validateJson<T>(schema: z.ZodType<T>, data: unknown): T` helper that parses and throws descriptive errors

3. Create `app/src/lib/atomic-write.ts`:
   - `atomicWriteJson(filePath: string, data: unknown): void` — JSON.stringify with 2-space indent + newline, write to `${filePath}.tmp.${process.pid}`, then `fs.renameSync(tmpPath, filePath)`. Wrap in try/catch that cleans up tmp file on error.
   - `atomicWriteJsonl(filePath: string, line: unknown): void` — appendFileSync a JSON.stringify(line) + "\n" to the file. Create parent dirs with mkdirSync({recursive:true}) if needed. Note: JSONL append is already atomic at OS level for single lines under 4KB, so no tmp+rename needed for append. The tmp+rename pattern is for full-file writes only.
   - Use `import fs from "node:fs"` and `import path from "node:path"`
  </action>
  <verify>
Run: `cd /home/tomas/Escritorio/AIAIAI_Consulting/app && npx tsc --noEmit`
Confirm no TypeScript errors. Manually verify schemas.ts exports match existing interfaces in data.ts.
  </verify>
  <done>Zod schemas exist for all 5 data shapes. atomicWriteJson uses tmp+rename pattern. atomicWriteJsonl uses append. TypeScript compiles cleanly.</done>
</task>

<task type="auto">
  <name>Task 2: JSONL history utilities and budget config extraction</name>
  <files>app/src/lib/jsonl.ts, data/config/budget.json, data/history/.gitkeep</files>
  <action>
1. Create `app/src/lib/jsonl.ts`:
   - `getMonthlyPath(baseDir: string, metric: string, date?: Date): string` — returns `${baseDir}/${metric}/${metric}-YYYY-MM.jsonl` using date (default: now). Example: `data/history/tokens/tokens-2026-01.jsonl`
   - `appendJsonl(baseDir: string, metric: string, entry: unknown, date?: Date): void` — calls getMonthlyPath, ensures directory exists with mkdirSync({recursive:true}), appends JSON.stringify(entry)+"\n" via fs.appendFileSync
   - `readJsonl<T>(filePath: string, schema: z.ZodType<T>): T[]` — reads file, splits by "\n", filters empty lines, parses each line with JSON.parse then schema.parse, returns array. If file doesn't exist, return [].
   - `listHistoryFiles(baseDir: string, metric: string): string[]` — returns sorted list of JSONL files for a metric using fs.readdirSync + filter *.jsonl

2. Create directory structure:
   - `mkdir -p data/history/tokens data/history/quality data/history/projects data/config`
   - Create `data/history/.gitkeep` (empty file)

3. Extract budget config from tokens.json:
   - Read current tokens.json, extract the `budget` object
   - Write to `data/config/budget.json`: `{ "monthly": 200, "currency": "USD" }`
   - Do NOT modify tokens.json yet (that happens in plan 05-02 when data.ts is updated)
  </action>
  <verify>
Run: `cd /home/tomas/Escritorio/AIAIAI_Consulting/app && npx tsc --noEmit`
Verify: `ls data/history/tokens data/history/quality data/history/projects data/config/budget.json`
Verify budget.json contains: `cat data/config/budget.json` shows monthly: 200
  </verify>
  <done>JSONL utilities create monthly-rotated files. History directories exist. Budget config extracted to data/config/budget.json. TypeScript compiles.</done>
</task>

</tasks>

<verification>
1. `cd app && npx tsc --noEmit` — zero errors
2. `node -e "const s = require('./app/src/lib/schemas'); console.log(Object.keys(s))"` — shows all schema exports (may need ts-node or tsx)
3. `ls data/config/budget.json data/history/.gitkeep` — both exist
4. `cat data/config/budget.json` — shows `{"monthly":200,"currency":"USD"}`
</verification>

<success_criteria>
- Zod schemas exist for Project, TokenEntry, TokenData, QualityEntry, BudgetConfig, HistoryEntry
- atomicWriteJson uses tmp+rename pattern (grep for renameSync confirms)
- JSONL utilities support monthly rotation with YYYY-MM naming
- Budget config lives in data/config/budget.json
- All TypeScript compiles without errors
</success_criteria>

<output>
After completion, create `.planning/phases/05-data-infrastructure/05-01-SUMMARY.md`
</output>
